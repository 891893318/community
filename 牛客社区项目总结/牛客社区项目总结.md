# 仿牛客社区项目总结

## 一、整体结构（绝大部分功能以及用到的绝大部分技术）

![1](images\1.png)

### 1、从技术来看

  - 构建在`Springboot`之上，其他技术均依托在`Springboot`之上
  - `Springboot`起辅助作用，降低其他技术使用难度
  - **核心**在于`Spring`，基本上所有均围绕`Spring`展开，**重点：`Spring、Interceptor、AOP、Transanction、Redis、Caffeine、SPring Security`**
    - `Spring MVC`：解决了前后端请求处理、交互的问题
    - `Spring Mybatis`：处理与数据库的连接
    - `Spring Security`：管理项目中的安全层面的问题，管理项目权限
    - **这三个构建在`Spring`之上，由`Spring`进行整合，整个项目的基石，绝大部分基于这些技术** 

#### 权限模块

  - `Spring Email`、以及`Spring MVC` 中的`Interceptor`（拦截器）
  - **`Interceptor`：能拦截所有请求，解决一些通用的问题，涉及面广**
  - **会话管理：没有会话管理后端记不住前端（类似于看新闻网站），长期交互，连续交互，必须要有会话管理。**
    - **了解`cookie、session`各自作用，区别？**
    - **后来规避`session`：考虑分布式部署可能会有一些问题？**
    - **不用`session`之后，将数据存到`Redis`里面**

#### 核心

- 首页，帖子，评论，私信基于`Spring MVC`实现的
- 异常、日志用到了一些通用的技术
- **敏感词过滤，相关技术：前缀树相关算法**
- **事务：解决了一些事务管理的一些问题：**
  - **事务是怎么回事？**
  - **事务的隔离级别？**
  - **`Spring`如何管理事务**
- `Advice`：控制器的通知，统一处理了异常
- **`AOP`：统一记录了业务层的日志**

#### 性能

- 点赞、关注等常见功能需要高频访问
- **`Redis`：开发点赞、关注等对性能有要求的功能，不只是开发这些，还能做出一些比如：统计网站UV、活跃用户等，`Redis`做缓存，提高性能**
- **`Redis`数据结构各自适合什么样的问题，适合什么样的数据！！**

#### 通知

- 消息队列的框架：`kafka`
- `kafka`：关注框架背后的一些通用的原则，**生产者与消费者模式，以及什么时候用这个来解决问题？**

#### 搜索

- `Elasticsearch`：使用简单，**关注数据结构**
- **`Elasticsearch`把数据单独存一份，存的方式与数据库不一样，以索引方式存，重点关注索引的结构，相关文章？？**

#### 其他

- **线程池（`Quartz`背后的一些原则）**
- **`Caffeine`：解决缓存问题，提高性能，本地缓存，分布式部署有一定局限性，结合`Redis`**



### 2、整体角度（运维角度）

![2](images\2.png)

- **客户端向服务器发送请求**
  - **请求分两类：一类静态（比如图片，css文件，js文件），一类动态（访问controller，要求返回动态数据）。这两种在服务端部署时候，是由不同的服务器处理**
    - **动态请求：发给`Nginx`，`Nginx`部署主、从**
    - **静态请求：把静态资源部署到`CDN`,好处在于缓存服务提供商在全国各地都有服务器，用户就近加载，速度快**
  - **`Nginx`在访问后会把请求分发给众多`Server`中的一个**
  - **`server`访问数据库`DB`读写两台，同步**
  - **`Redis`：也是起到缓存作用，本地缓存有，直接返回，本地缓存没有，看`Redis`,否则访问数据库**
  - `kafka`：应用中也是可以部署任意多个
  - `Elasticsearch`：也是可以多个，访问其中一个搜索数据
  - 文件：类似（第三方）
- **面试相关：**
  - **职业素养：算法、数据结构**
  - **项目经验：技术栈，不拖后腿**
  - **钻研能力，独立解决问题能力**





## 二、知识点

### 1、`MySQL`：存储引擎、事务、锁、索引

- **存储引擎：**

  - **`InnoDB`：这是`MySQL`的默认存储引擎，它支持事务、行级锁定和外键，适用于需要强数据一致性和事务支持的应用程序。**
  - **`MyISAM`：虽然不支持事务，但它对于读密集型应用程序效果很好，如博客或新闻网站。**
  - **`MEMORY`：将数据存储在内存中，适用于快速访问临时数据的情况。**
  - **`CSV`：用于存储`CSV`格式的数据。**
  - **`ARCHIVE`：适用于高度压缩的存储。**

- **事务：**表示一系列操作作为一个不可分割的工作单元，要么全部成功执行，要么全部失败回滚，以保持数据的一致性和完整性。事务通常用于处理对数据库或其他资源的修改，以确保数据在操作中的状态转换是可控的、可恢复的，不会出现不一致或损坏的情况。

  - **事务的特性：原子性、一致性、隔离性、持久性**
    - **原子性**：原子性是指事务是不可分割的工作单元，要么全部成功执行，要么全部失败回滚。如果在事务执行过程中发生错误，所有对数据的修改都会被撤销，使数据保持一致状态。
    - **一致性：**确保事务在执行前后数据库从一个一致的状态转移到另一个一致的状态。这意味着事务的执行不会破坏数据库的完整性约束（如唯一键、外键关系等），确保数据的合法性。
    - **持久性：**持久性确保一旦事务成功提交，其对数据库的修改将永久保存，即使在系统崩溃或断电的情况下也不会丢失。通常，数据库系统会将事务的变更记录到持久性存储介质（如硬盘）上，以确保数据的持久性
    - **隔离性：**
      - **隔离级别**：
        - **读未提交`（Read Uncommitted）`**：在这个最低级别的隔离中，一个事务可以读取到另一个事务未提交的数据。这种隔离级别的特点是并发性最高，但也是最不安全的，可能导致脏读（读到未提交数据）、不可重复读和幻读等问题。
        - **读提交`（Read Committed）`**：这是MySQL的默认隔离级别。它确保一个事务只能读取到已经提交的数据，避免了脏读问题。但仍然可能出现不可重复读和幻读问题。
        - **可重复读`（Repeatable Read）`**：在这个隔离级别下，一个事务在开始后看到的数据将保持不变，即使其他事务对相同数据进行了修改。这可以避免不可重复读问题，但仍然可能存在幻读问题。
        - **串行化`（Serializable）`**：这是最高的隔离级别，它确保事务之间的完全隔离，避免了脏读、不可重复读和幻读等问题。但串行化级别的并发性最差，因为它会限制多个事务同时对相同数据进行访问。
      - **并发异常：**
        - **第一类丢失更新`（First Lost Update）`**：
          - 第一类丢失更新发生在两个或多个事务同时尝试更新同一数据时。
          - 这种问题通常在低隔离级别下出现，如读未提交或读提交。
          - 在第一类丢失更新中，一个事务的更新可能会覆盖另一个事务的更新，导致某些更新被丢失。
          - 这种情况下，最后提交的事务的更改会覆盖之前提交的事务的更改，而之前提交的事务的更改将丢失。
        - **第二类丢失更新`（Second Lost Update）`**：
          - 第二类丢失更新也是在多个事务同时尝试更新同一数据时发生的问题。
          - 不同于第一类丢失更新，第二类丢失更新发生在一个事务内的两个更新操作之间。
          - 例如，一个事务首先读取数据，然后进行一些计算，最后再次更新数据。如果在计算期间有其他事务更新了相同的数据，那么在第一个事务提交时，它的更新将覆盖其他事务的更改。
          - 这种情况下，第一个事务的计算可能基于过时的数据，导致数据不一致性。
        - **脏读`（Dirty Read）`**：一个事务读取了另一个事务未提交的数据，如果另一个事务最终回滚，那么读取的数据就是无效的。
        - **不可重复读`（Non-Repeatable Read）`**：一个事务在多次读取相同数据时，由于其他事务的修改，每次读取的数据都不一样。
        - **幻读`（Phantom Read）`**：一个事务在多次查询同一个范围的数据时，由于其他事务的插入或删除，每次查询的结果都不一样

- **Spring事务管理的主要概念和用法：**

  - **声明式事务管理**：`Spring`支持通过`XML`配置或注解的方式来声明式管理事务。通过在方法或类上添加`@Transactional`注解，可以将方法标记为事务性的，以便`Spring`在方法调用前后自动开启、提交或回滚事务。

    ```java
    @Service
    public class MyService {
        @Autowired
        private MyRepository repository;
        
        @Transactional
        public void performSomeTransactionalOperation() {
            // 事务内的业务逻辑
            repository.save(data);
        }
    }
    ```

    

  - **编程式事务管理**：除了声明式事务管理，`Spring`还允许使用编程式事务管理。通过`TransactionTemplate`或`PlatformTransactionManager`接口，可以在代码中显式管理事务的开始、提交和回滚

    ```java
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    public void programmaticTransactionExample() {
        TransactionTemplate template = new TransactionTemplate(transactionManager);
        template.execute(status -> {
            // 事务内的业务逻辑
            return result;
        });
    }
    ```

  - **事务管理器**：`Spring`支持多种事务管理器，包括`JDBC`事务管理器、`Hibernate`事务管理器、`JTA`事务管理器等。

    ```xml
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    ```

  - **事务传播行为**：事务传播行为定义了在方法调用链中嵌套事务的行为。`Spring`提供了多种传播行为，如`REQUIRED`、`REQUIRES_NEW`、`NESTED`等

    ```Java
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        // ...
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // ...
    }
    ```

  - **事务隔离级别**：事务隔离级别定义了多个并发事务之间的隔离程度。`Spring`支持不同的隔离级别，包括`DEFAULT`、`READ_UNCOMMITTED`、`READ_COMMITTED`、`REPEATABLE_READ`和`SERIALIZABLE`。

    ```java
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void someTransactionalMethod() {
        // ...
    }
    ```

    

  - **回滚规则**：通过`@Transactional`注解的`rollbackFor`和`noRollbackFor`属性，可以自定义哪些异常触发事务回滚，哪些异常不触发回滚

    ```Java
    @Transactional(rollbackFor = MyCustomException.class)
    public void methodWithCustomRollback() throws MyCustomException {
        // ...
    }
    ```

- **锁：**一种同步机制，用于控制对共享资源的并发访问，以确保数据的一致性和完整性。锁可以用于多线程编程、多进程编程、分布式系统等多种情境中。

  ![3](images\3.png)

​			  ![4](images\4.png)

![5](C:\Users\J8820\Desktop\牛客社区项目总结\images\5.png)

![6](C:\Users\J8820\Desktop\牛客社区项目总结\images\6.png)

- **索引**

  **`InnoDB`引擎**：

  - `InnoDB`引擎是`MySQL`的默认存储引擎，它支持事务和外键，适用于需要强数据一致性和事务支持的应用程序。
  - `InnoDB`引擎采用聚簇索引`（Clustered Index）`的方式来组织数据，这意味着数据行本身就是按照索引顺序存储的，而不是像其他存储引擎那样分离存储数据和索引。
  - `InnoDB`引擎还支持非聚簇索引，用于辅助数据检索和加速查询。
  - 它使用`MVCC`（多版本并发控制）来实现事务隔离，允许多个事务同时读取和修改数据而不会相互干扰。
  - `InnoDB`引擎的性能和可靠性使其成为许多企业级应用程序的首选存储引擎。

  **B+树**：

  - B+树（B+ Tree）是一种自平衡树结构，通常用于数据库管理系统中的索引。
  - B+树具有良好的平衡性和高效的查询性能，它的高度相对较低，因此可以快速地定位到目标数据。
  - B+树的叶子节点存储了数据的实际值，内部节点用于导航到叶子节点，因此B+树的查询时间复杂度通常为`O(log n)`，其中n是索引中的数据项数量。
  - B+树的特点包括有序性（叶子节点按键值有序存储）、平衡性（树的高度基本一致）、适应性（可以自动调整树的结构以保持平衡）。
  - B+树还支持范围查询，因为数据按顺序存储，可以轻松获取范围内的数据。



### 2、`Redis`：数据类型、过期策略、缓存穿透、缓存击穿、缓存雪崩、分布式锁

#### 数据类型：

- **字符串（String）**：

  - 特点：存储文本或二进制数据，是最简单的数据类型。

  - 最大存储数据量：每个键值对的最大存储容量为512MB。

- **列表（List）**：

  - 特点：有序的字符串集合，支持在列表的两端添加或删除元素。

  - 最大存储数据量：最多可以存储2^32 - 1个元素。

- **集合（Set）**：

  - 特点：无序的字符串集合，支持添加、删除和查找元素。

  - 最大存储数据量：最多可以存储2^32 - 1个元素。

- **有序集合（Sorted Set）**：
  - 特点：类似于集合，但每个元素都有一个分数，可以按照分数排序。

- **哈希表（Hash）**：

  - 特点：类似于关联数组，可以存储多个字段和值的映射。

  - 最大存储数据量：每个哈希表可以存储2^32 - 1个字段-值对。

- **位图（Bitmap）**：

  - 特点：用于处理位操作的数据类型，通常用于统计、布隆过滤器等功能。

  - 最大存储数据量：每个位图可以包含2^32个位。

#### 过期策略

- **`Redis`的过期策略是指控制数据在`Redis`中的存活时间以及数据何时被自动删除的策略。过期策略可以用于实现缓存数据的自动失效、会话管理以及限制内存占用等目的。`Redis`支持两种主要的过期策略：**

  - **绝对过期时间**：

    - 在设置键值对时，可以为键设置一个绝对过期时间`（TTL，Time To Live）`，以秒为单位。

    - 例如，使用`SET key value EX 3600`命令可以将键值对的过期时间设置为1小时，1小时后数据将自动被删除。

    - 绝对过期时间是相对于键的设置时间来计算的，而不是相对于访问时间。

  - **惰性删除**：

    - `Redis`不会立即在键过期时删除它，而是等到键被访问时才会检查它是否过期，如果过期则删除。

    - 这种策略被称为惰性删除，它可以减少定期删除操作的频率，提高性能。

    - 惰性删除的缺点是，如果某个键很少被访问，它可能会在过期后仍然占用内存。

- 当Redis占用的内存超出最大限制时，可能会导致系统性能下降，甚至出现崩溃。为了避免这种情况，需要采取一些措施来管理Redis的内存使用。以下是一些可能的解决方案：

  - **使用内存管理策略**：

    - Redis提供了一些内存管理策略，如`maxmemory`和`maxmemory-policy`选项，可以通过配置文件或动态设置来控制Redis的内存使用。

    - `maxmemory`用于设置Redis允许使用的最大内存量，可以通过配置文件或命令行设置。例如，`maxmemory 1GB`表示Redis最多使用1GB的内存。

    - `maxmemory-policy`用于指定在内存不足时如何选择要删除的键，有多种策略可供选择，包括LRU（最近最少使用）、LFU（最不经常使用）、随机等。

  - **数据持久化**：

    - 使用Redis的数据持久化机制，如RDB快照和AOF日志，将数据保存到磁盘上，以释放内存。

    - 当Redis内存占用超出限制时，可以触发RDB快照或AOF日志的写入，将部分数据写入磁盘，然后删除内存中的数据。

    - 这种方式虽然会增加磁盘IO负载，但可以防止内存溢出。

  - **设置过期时间**：

    - 使用合理的过期时间（TTL）来确保缓存中的数据不会永久驻留在内存中。

    - 对于不再需要的数据，可以主动设置过期时间，让Redis在过期后自动删除它们。

  - **使用分布式架构**：

    - 将Redis部署为分布式集群，将数据分散存储在多个节点上，从而扩展可用内存。

    - 这可以通过Redis Cluster或使用分片技术来实现。

  - **升级硬件或扩展资源**：
    - 如果内存使用频繁达到极限，考虑升级服务器硬件，增加内存容量，或添加更多的Redis实例来分担负载。

  - **监控和警报**：

    - 部署监控工具，实时监测Redis的内存使用情况。

    - 设置警报机制，当内存使用达到一定阈值时触发警报，以便及时采取措施。

#### 缓存穿透

缓存穿透是指恶意或非恶意的查询缓存中不存在的数据，导致每次请求都要访问数据库，对数据库和缓存服务器造成不必要的压力。缓存穿透通常发生在以下情况下：

- **查询不存在的数据**：用户请求一个不存在于缓存和数据库中的数据，例如查询一个不存在的用户ID。

- **攻击性请求**：恶意用户或攻击者可能故意发送无效的请求来绕过缓存，以触发数据库查询

  **解决方案**：

1. **布隆过滤器（Bloom Filter）**：
   - **布隆过滤器是一种快速的、概率性的数据结构，用于检查一个元素是否可能存在于一个集合中。它通常用于缓存穿透的防护，以尽早拦截无效的请求，减轻数据库负载。**
   - **布隆过滤器由一组位（bit array）和一组哈希函数组成。它的工作原理如下：**
     1. **初始化：创建一个位数组，所有位都初始化为0。**
     2. **添加元素：对于要加入的每个元素，通过多个哈希函数将其映射到位数组中的多个位置，并将这些位置的位设置为1。**
     3. **查询元素：对于要查询的元素，同样通过多个哈希函数映射到位数组中的多个位置，如果所有位置的位都是1，则说明元素可能存在，如果有一个位置的位不是1，则可以确定元素不存在。**
   - **布隆过滤器具有以下特点：**
     - **节省内存：相对于将所有元素存储在内存中，布隆过滤器使用的内存通常较少。**
     - **快速查询：查询操作非常快速，因为只需要检查位数组中的若干位。**
     - **概率性：布隆过滤器可能会产生误判，即将不存在的元素误认为存在，但不会误判将存在的元素。**
   - **在防止缓存穿透中，可以使用布隆过滤器来预先将可能有效的键（或查询参数）加入到布隆过滤器中。当收到一个查询请求时，首先将查询参数通过多个哈希函数映射到布隆过滤器中，如果任何一个哈希位置的位为0，就可以立即判定查询参数对应的数据不存在于缓存中，从而避免了不必要的数据库查询。**
2. **空对象缓存**：
   - **空对象缓存是指在查询数据库返回空结果时，将这个结果缓存起来，并为其设置一个较短的过期时间，通常比正常数据的缓存时间要短。**
   - **这个策略的核心思想是，当某个查询请求在缓存中找不到数据时，不仅可以避免多次查询数据库，还可以避免频繁地检查布隆过滤器。**
   - **具体步骤如下：**
     1. **收到一个查询请求，首先检查缓存，如果缓存中存在数据，直接返回数据。**
     2. **如果缓存中不存在数据，查询数据库。**
     3. **如果数据库返回了空结果，将这个空结果（通常是一个特殊值，如null）缓存起来，但设置一个较短的过期时间，比如几分钟。**
     4. **返回空结果给客户端。**
   - **这样，如果后续请求再次查询相同的数据，就可以从缓存中获取到空结果，而不需要再次查询数据库，减轻了数据库负载。较短的过期时间确保了即使数据库中的数据发生变化，缓存也会在不久后自动失效，从而避免了数据不一致性**



#### 缓存击穿

**缓存击穿是指在高并发环境下，某个缓存键的数据过期或不存在，同时有大量的请求同时访问这个缓存键，导致这些请求都穿透缓存，直接查询数据库，从而造成数据库负载激增的现象。缓存击穿通常是由以下原因引起的：**

1. **热点数据**：某些数据非常热门，被大量请求访问，但由于缓存过期或尚未加载到缓存中，每次请求都需要查询数据库。
2. **定时过期**：缓存键设置了定时过期时间，当缓存过期后，如果有大量请求同时到来，它们会同时查询数据库。

**为了防止缓存击穿，可以采取以下策略：**

1. **使用互斥锁：**
   - 当检测到某个缓存键过期或不存在时，可以使用互斥锁来防止多个请求同时查询数据库。
   - 第一个请求获取锁并查询数据库，其他请求等待锁释放后再次查询缓存或数据库。
2. **设置短期随机过期时间：**
   - 在设置缓存键的过期时间时，可以引入随机因素，使过期时间在一定范围内变化。
   - 这样可以避免大量的请求在同一时刻过期并同时访问数据库。
3. **缓存预热：**
   - 针对热门数据，可以在应用启动时或数据更新时提前加载到缓存中，从而避免缓存键过期后被请求击穿。
4. **使用哨兵模式或分布式锁：**
   - 在分布式系统中，可以使用哨兵模式或分布式锁来确保只有一个节点能够查询数据库，其他节点等待结果返回。
5. **失败缓存：**
   - 当某个缓存键的数据无法从数据库中加载时，可以设置一个失败缓存，将失败的查询结果也缓存起来，但设置一个短期过期时间。
   - 这样可以避免频繁查询数据库，即使数据加载失败，也能够快速恢复。
6. **监控和警报：**
   - 部署监控工具，实时监测缓存击穿的情况，当发现异常请求频繁时及时发出警报，并采取措施应对。



#### 缓存雪崩

**缓存雪崩是指在某个时间点，大量缓存中的数据同时过期，导致数据库负载急剧增加，甚至导致数据库宕机。缓存雪崩通常是由以下原因引起的：**

1. 相同的过期时间：如果大量缓存键都设置了相同的过期时间，它们会在同一时刻过期，导致大规模的请求同时访问数据库。
2. 缓存服务器宕机：如果缓存服务器宕机或重启，所有缓存数据都会丢失，导致所有请求都需要查询数据库。
3. 大批量的数据更新：如果一次性更新了大量缓存数据，例如批量导入数据并刷新缓存，可能会导致数据库负载激增。

**为了防止缓存雪崩，可以采取以下策略：**

1. **设置不同的过期时间：**
   - 为了避免缓存键在同一时刻过期，可以为不同的缓存键设置稍微不同的过期时间，例如在原有的过期时间上添加一个随机的偏移量。
   - 这样可以确保不同的缓存数据在不同的时间过期，减少了同时查询数据库的概率。
2. **使用持久化和备份缓存：**
   - 使用持久化机制，如Redis的RDB快照和AOF日志，将缓存数据保存到磁盘上，以便在缓存服务器宕机后能够快速恢复数据。
   - 设置备份缓存，即在主缓存故障时可以快速切换到备份缓存，以保持系统的可用性。
3. **分布式缓存：**
   - 使用分布式缓存系统，如Redis Cluster或Memcached集群，将缓存数据分布在多个节点上，减少单点故障的风险。
   - 分布式缓存还可以均衡负载，降低缓存服务器的压力。
4. **限流和降级：**
   - 当缓存服务器出现故障或不可用时，可以实施限流策略，限制请求的流量，以降低数据库的负载。
   - 在缓存不可用时，还可以采取降级策略，返回默认值或错误信息，而不是查询数据库



#### 分布式锁（重点）

分布式锁是一种用于分布式系统中的并发控制机制，用于确保在多个节点上的并发操作中只有一个节点能够执行关键代码块，从而避免竞态条件和数据不一致性的问题。分布式锁通常用于协调分布式系统中的各个节点，以防止资源争夺和数据冲突。以下是关于分布式锁的详细解释：

1. **用途**：
   - 分布式锁通常用于以下情况：
     - 防止多个节点同时修改共享资源，确保资源的互斥访问。
     - 控制多个节点中只有一个节点能够执行某个关键任务，例如定时任务、数据同步等。
     - 防止多个客户端同时对一个共享资源进行操作，确保数据一致性。
2. **实现方式**：
   - 分布式锁可以通过不同的方式来实现，其中一些常见的方式包括：
     - 基于数据库：使用数据库的事务和唯一性约束来实现锁。
     - 基于缓存：使用分布式缓存，如Redis，通过SETNX（Set If Not Exists）命令来实现锁。
     - 基于ZooKeeper：使用ZooKeeper分布式协调服务来实现锁。
     - 基于分布式锁服务：使用专门的分布式锁服务，如etcd、Consul等。
3. **锁的特性**：
   - 分布式锁通常具有以下特性：
     - 互斥性：在任何时刻，只有一个客户端或节点能够持有锁。
     - 阻塞或非阻塞：获取锁的方式可以是阻塞式或非阻塞式。
     - 超时和自动释放：锁可以设置超时时间，如果超过一定时间没有释放锁，系统会自动释放锁。
     - 可重入性：同一个客户端或节点可以多次获取同一把锁，通常需要支持锁的可重入性。
     - 安全性：锁的实现需要具备高可用性、数据安全和避免死锁等特性。
4. **常见问题**：
   - 在分布式锁的实现中，需要考虑一些常见问题，如锁的超时和续租、死锁的检测和解决、锁的释放和竞争等问题。
5. **使用场景**：
   - 分布式锁广泛应用于分布式系统中，包括但不限于以下场景：
     - 数据库分片（Sharding）：确保在分片数据库中的事务不会冲突。
     - 分布式任务调度：确保任务只被一个节点执行。
     - 分布式缓存同步：在多个缓存节点之间同步数据。

### 3、`Spring`：`Spring IoC、Spring AoP、Spring MVC`

#### `Spring IoC`：


`Spring IoC（Inversion of Control，`控制反转）是Spring框架的核心概念之一，它是一种设计思想和编程范式，用于解耦组件之间的依赖关系。在传统的应用程序中，通常是组件自己负责创建和管理它们所依赖的其他组件，而在IoC容器中，控制权发生了反转，容器负责创建和管理组件，组件只需要声明它们所依赖的其他组件，由容器来进行注入。以下是关于Spring IoC的详细解释：

1. **`IoC`容器**：
   - `Spring IoC`容器是一个负责管理应用程序中所有组件的容器。它负责创建、配置、装配和管理组件之间的依赖关系。`Spring`提供了多种类型的`IoC`容器，其中最常用的是`BeanFactory`和`ApplicationContext`。
2. **`Bean`**：
   - 在Spring中，被IoC容器管理的对象被称为"`Bean`"。`Bean`是应用程序的基本构建块，可以是任何`Java`对象。通常，`Bean`代表了应用程序中的各种组件，如服务、数据访问对象、控制器等。
3. **依赖注入`（Dependency Injection，DI）`**：
   - 依赖注入是`IoC`的一个关键概念，它指的是将一个Bean所依赖的其他`Bean`注入到它内部，而不是由Bean自己去创建这些依赖对象。这样可以降低组件之间的耦合度，提高可测试性和可维护性。
4. **配置元数据**：
   - 在`IoC`容器中，`Bean`的创建和配置是通过配置元数据来实现的，通常使用`XML、Java`配置类或注解来定义`Bean`及其依赖关系。配置元数据告诉`IoC`容器如何创建、初始化和装配Bean。
5. **装配**：
   - 装配是指将`Bean`之间的依赖关系建立起来，使它们能够协同工作。Spring提供了多种方式来进行装配，包括构造函数注入、`Setter`方法注入、字段注入和接口注入等。
6. **Bean的生命周期**：
   - `Spring IoC`容器管理`Bean`的完整生命周期，包括`Bean`的创建、初始化、使用和销毁。开发者可以通过配置特定的方法来实现`Bean`的初始化和销毁逻辑。
7. **Bean的作用域**：
   - `Spring`允许定义`Bean`的作用域，常见的作用域包括`Singleton`（单例，一个容器只有一个实例）、`Prototype`（原型，每次请求都创建一个新实例）以及其他自定义作用域。
8. **AOP支持**：
   - `Spring IoC`容器还提供了`AOP（Aspect-Oriented Programming）`支持，使开发者可以更容易地实现横切关注点`（cross-cutting concerns）`的功能，例如日志、事务、安全等。

Spring IoC容器的核心思想是将组件之间的依赖关系委托给容器来管理，从而实现松散耦合、可维护和可测试的应用程序。通过IoC容器，开发者可以更容易地管理Bean的生命周期、实现依赖注入和实现AOP，从而提高了应用程序的可扩展性和可维护性。

![7](images\7.png)



#### `Spring AoP`

`Spring AOP` `（Aspect-Oriented Programming`，面向切面编程）是`Spring`框架的一个重要模块，用于处理应用程序中的横切关注点`（cross-cutting concerns）`，例如日志、事务、安全、性能监控等。`AOP`允许开发者将这些关注点从业务逻辑中分离出来，从而提高代码的模块化性和可维护性。以下是关于`Spring AOP`的详细解释：

1. **切面（`Aspect`）**：
   - 切面是一种模块化的方式来定义与横切关注点相关的行为。切面可以包含通知`（Advice）`和切点`（Pointcut）`。
2. **通知（`Advice`）**：
   - 通知定义了在切点上执行的操作。`Spring AOP`提供了以下类型的通知：
     - **前置通知`（Before Advice）`**：在目标方法执行前执行。
     - **后置通知`（After Advice）`**：在目标方法执行后执行，无论方法是否正常返回。
     - **返回通知`（After Returning Advice）`**：在目标方法正常返回后执行。
     - **异常通知（`After Throwing Advice）`**：在目标方法抛出异常后执行。
     - **环绕通知`（Around Advice）`**：在目标方法前后执行，可以完全控制方法的执行流程。
3. **切点`（Pointcut）`**：
   - 切点是一个表达式，用于描述哪些方法应该被应用哪些通知。它定义了横切关注点的具体位置。切点通常使用`AspectJ`表达式来定义。
4. **连接点`（Join Point）`**：
   - 连接点是在应用程序执行期间，切点可以匹配的特定点，例如方法调用或异常抛出。连接点是`AOP`的实际执行点。
5. **切面的织入`（Weaving）`**：
   - 织入是将切面与应用程序代码关联起来的过程。`Spring`支持多种织入方式，包括编译时织入、类加载时织入、运行时织入等。Spring通常使用运行时织入，因为它可以在不修改源代码的情况下将切面应用到已编译的类上。
6. **目标对象`（Target Object）`**：
   - 目标对象是被通知的实际业务对象。通知在目标对象的方法上执行。
7. **引入`（Introduction）`**：
   - 引入允许开发者向现有的类添加新的方法和属性。`Spring AOP`允许在不修改现有代码的情况下引入新功能。
8. **AOP代理`（AOP Proxy`）**：
   - `AOP`代理是`AOP`框架为目标对象生成的代理对象，用于应用通知。`Spring AOP`支持两种代理类型：`JDK`动态代理和`CGLIB`代理，具体的代理方式取决于目标对象是否实现了接口。

#### `Spring MVC` (重点)

`Spring MVC（Model-View-Controller）`是`Spring`框架的一个模块，用于构建基于`Java`的`Web`应用程序。它提供了一种设计模式和一组组件，以便开发者可以轻松地构建Web应用程序，并将应用程序的不同层次（数据模型、用户界面和控制器）分离开来，从而提高了应用程序的可维护性和可扩展性。以下是关于`Spring MVC`的详细解释：

1. **`MVC`设计模式**：
   - `MV`C是一种设计模式，用于将Web应用程序的不同职责分离开来。它将应用程序分为三个核心组件：
     - **`Model`（模型）**：代表应用程序的数据和业务逻辑。模型负责管理数据的状态和处理数据的操作。
     - **`View`（视图）**：负责渲染数据并呈现给用户的组件。视图通常是用户界面的一部分，可以是`HTML、JSP、Thymeleaf`等模板。
     - **`Controller`（控制器）**：负责处理用户请求、调用适当的模型处理逻辑，并将结果传递给视图进行渲染。控制器充当模型和视图之间的协调者。
2. **`Spring MVC`架构**：
   - `Spring MVC`框架建立在传统MVC设计模式之上，它提供了一组组件来支持Web应用程序的开发。这些组件包括`DispatcherServlet`、`HandlerMapping`、`Controller`、`ViewResolver`等。
   - `DispatcherServlet`是Spring MVC的中央控制器，负责接收和分派所有的HTTP请求。它根据请求的URL找到适当的`Controller`并调用其方法处理请求。
   - `HandlerMapping`用于将URL映射到具体的控制器。
   - `Controller`是应用程序的控制器，它包含了处理HTTP请求的方法。
   - `ViewResolver`负责将控制器返回的视图名称映射到实际的视图模板。
3. **请求处理流程**：
   - `Spring MVC`的请求处理流程通常如下：
     1. 客户端发送HTTP请求。
     2. `DispatcherServlet`接收请求，并使用`HandlerMapping`找到合适的控制器。
     3. 控制器处理请求，执行业务逻辑，然后返回一个`ModelAndView`对象。
     4. `DispatcherServlet`使用`ViewResolver`解析视图名称，并选择合适的视图模板。
     5. 视图模板渲染数据，生成HTML响应。
     6. 响应返回给客户端。
4. **注解支持**：
   - `Spring MVC`支持使用注解来配置控制器、处理请求映射、数据绑定等。这使得开发者可以使用更简洁的方式定义控制器和请求映射。
5. **数据绑定和校验**：
   - `Spring MVC`提供了强大的数据绑定功能，可以将HTTP请求参数自动绑定到控制器方法的参数中。同时，它支持数据校验，可以验证绑定的数据是否符合预期。
6. **`RESTful Web`服务支持**：
   - `Spring MV`C也支持构建`RESTful Web`服务，通过使用注解和`HTTP`方法来定义资源和操作。
7. **拦截器（`Interceptors`）**：
   - 拦截器允许在请求处理前后执行一些通用操作，如日志记录、权限检查、数据预处理等。

`Spring MVC`是一个强大的`Web`框架，它提供了丰富的功能和灵活性，使开发者能够构建各种类型的`Web`应用程序，包括传统的`Web`应用程序、`RESTful Web`服务和单页应用程序`（SPA）`。它的模块化和可扩展性使得它成为`Java Web`开发的首选框架之一。

![8](images\8.png)